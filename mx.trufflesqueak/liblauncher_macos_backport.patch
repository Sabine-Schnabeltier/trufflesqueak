diff --git a/sdk/mx.sdk/mx_sdk_vm_impl.py b/sdk/mx.sdk/mx_sdk_vm_impl.py
index 7fd5bdbdc8e..3e525e11613 100644
--- a/sdk/mx.sdk/mx_sdk_vm_impl.py
+++ b/sdk/mx.sdk/mx_sdk_vm_impl.py
@@ -2742,6 +2742,8 @@ class NativeLibraryLauncherProject(mx_native.DefaultNativeProject):
         ]
         if not mx.is_windows():
             _dynamic_cflags += ['-pthread']
+        if mx.is_darwin():
+            _dynamic_cflags += ['-ObjC++']
 
         _graalvm_home = _get_graalvm_archive_path("")
 
@@ -2807,6 +2809,8 @@ class NativeLibraryLauncherProject(mx_native.DefaultNativeProject):
         _dynamic_ldlibs = []
         if not mx.is_windows():
             _dynamic_ldlibs += ['-ldl']
+        if mx.is_darwin():
+            _dynamic_ldlibs += ['-framework', 'Foundation']
         return super(NativeLibraryLauncherProject, self).ldlibs + _dynamic_ldlibs
 
     def default_language_home_relative_libpath(self):
diff --git a/sdk/src/org.graalvm.launcher.native/src/launcher.cc b/sdk/src/org.graalvm.launcher.native/src/launcher.cc
index 4f9c7450682..94d05906aa9 100644
--- a/sdk/src/org.graalvm.launcher.native/src/launcher.cc
+++ b/sdk/src/org.graalvm.launcher.native/src/launcher.cc
@@ -115,6 +115,11 @@
     #endif
     #define LIBJLI_RELPATH_STR STR(LIBJLI_RELPATH)
 
+    /* Support Cocoa event loop on the main thread */
+    #include <Cocoa/Cocoa.h>
+    #include <objc/objc-runtime.h>
+    #include <objc/objc-auto.h>
+
 #elif defined (_WIN32)
     #include <windows.h>
     #include <libloaderapi.h>
@@ -376,6 +381,41 @@ void parse_vm_options(int argc, char **argv, std::string exeDir, JavaVMInitArgs
     }
 }
 
+static int jvm_main_thread(int argc, char *argv[], std::string exeDir, char *jvmModeEnv, bool jvmMode, std::string libPath);
+
+#if defined (__APPLE__)
+static void dummyTimer(CFRunLoopTimerRef timer, void *info) {}
+
+static void ParkEventLoop() {
+    // RunLoop needs at least one source, and 1e20 is pretty far into the future
+    CFRunLoopTimerRef t = CFRunLoopTimerCreate(kCFAllocatorDefault, 1.0e20, 0.0, 0, 0, dummyTimer, NULL);
+    CFRunLoopAddTimer(CFRunLoopGetCurrent(), t, kCFRunLoopDefaultMode);
+    CFRelease(t);
+
+    // Park this thread in the main run loop.
+    int32_t result;
+    do {
+        result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e20, false);
+    } while (result != kCFRunLoopRunFinished);
+}
+
+struct MainThreadArgs {
+    int argc;
+    char **argv;
+    std::string exeDir;
+    char *jvmModeEnv;
+    bool jvmMode;
+    std::string libPath;
+};
+
+static void *apple_main (void *arg)
+{
+    struct MainThreadArgs *args = (struct MainThreadArgs *) arg;
+    int ret = jvm_main_thread(args->argc, args->argv, args->exeDir, args->jvmModeEnv, args->jvmMode, args->libPath);
+    exit(ret);
+}
+#endif /* __APPLE__ */
+
 int main(int argc, char *argv[]) {
     debug = (getenv("VERBOSE_GRAALVM_LAUNCHERS") != NULL);
     std::string exeDir = exe_directory();
@@ -400,8 +440,31 @@ int main(int argc, char *argv[]) {
             return -1;
         }
     }
+
+    struct MainThreadArgs args = { argc, argv, exeDir, jvmModeEnv, jvmMode, libPath};
+
+    /* Create dedicated "main" thread for the JVM. The actual main thread
+     * must run the UI event loop on macOS. Inspired by this OpenJDK code:
+     * https://github.com/openjdk/jdk/blob/011958d30b275f0f6a2de097938ceeb34beb314d/src/java.base/macosx/native/libjli/java_md_macosx.m#L328-L358
+     */
+    pthread_t main_thr;
+    if (pthread_create(&main_thr, NULL, &apple_main, &args) != 0) {
+        std::cerr << "Could not create main thread: " << strerror(errno) << std::endl;
+        return -1;
+    }
+    if (pthread_detach(main_thr)) {
+        std::cerr << "pthread_detach() failed: " << strerror(errno) << std::endl;
+        return -1;
+    }
+
+    ParkEventLoop();
+    return 0;
+#else
+    return jvm_main_thread(argc, argv, exeDir, jvmModeEnv, jvmMode, libPath);
 #endif
+}
 
+static int jvm_main_thread(int argc, char *argv[], std::string exeDir, char *jvmModeEnv, bool jvmMode, std::string libPath) {
     /* parse VM args */
     JavaVM *vm;
     JNIEnv *env;
